<<<<<<< HEAD
import type { Document } from '../bson';
=======
<<<<<<< HEAD
import type { Document } from '../bson';
=======
import type { Document, Long, Timestamp } from '../bson';
>>>>>>> origin/master
>>>>>>> da2dcd06e1a2d3788c7aa5c2e1802a945b20cf8a
import {
  ChangeStream,
  type ChangeStreamDocument,
  type ChangeStreamEvents,
  type OperationTime,
  type ResumeToken
} from '../change_stream';
<<<<<<< HEAD
import { type CursorResponse } from '../cmap/wire_protocol/responses';
=======
<<<<<<< HEAD
import { type CursorResponse } from '../cmap/wire_protocol/responses';
import { INIT, RESPONSE } from '../constants';
import type { MongoClient } from '../mongo_client';
import { AggregateOperation } from '../operations/aggregate';
import type { CollationOptions } from '../operations/command';
import { executeOperation } from '../operations/execute_operation';
import type { ClientSession } from '../sessions';
import { maxWireVersion, type MongoDBNamespace } from '../utils';
import {
  AbstractCursor,
  type AbstractCursorOptions,
  type InitialCursorResponse
} from './abstract_cursor';
=======
>>>>>>> da2dcd06e1a2d3788c7aa5c2e1802a945b20cf8a
import { INIT, RESPONSE } from '../constants';
import type { MongoClient } from '../mongo_client';
import { AggregateOperation } from '../operations/aggregate';
import type { CollationOptions } from '../operations/command';
import { executeOperation } from '../operations/execute_operation';
import type { ClientSession } from '../sessions';
import { maxWireVersion, type MongoDBNamespace } from '../utils';
<<<<<<< HEAD
import {
  AbstractCursor,
  type AbstractCursorOptions,
  type InitialCursorResponse
} from './abstract_cursor';
=======
import { AbstractCursor, type AbstractCursorOptions } from './abstract_cursor';
>>>>>>> origin/master
>>>>>>> da2dcd06e1a2d3788c7aa5c2e1802a945b20cf8a

/** @internal */
export interface ChangeStreamCursorOptions extends AbstractCursorOptions {
  startAtOperationTime?: OperationTime;
  resumeAfter?: ResumeToken;
  startAfter?: ResumeToken;
  maxAwaitTimeMS?: number;
  collation?: CollationOptions;
  fullDocument?: string;
}

/** @internal */
<<<<<<< HEAD
=======
<<<<<<< HEAD
=======
export type ChangeStreamAggregateRawResult<TChange> = {
  $clusterTime: { clusterTime: Timestamp };
  cursor: {
    postBatchResumeToken: ResumeToken;
    ns: string;
    id: number | Long;
  } & ({ firstBatch: TChange[] } | { nextBatch: TChange[] });
  ok: 1;
  operationTime: Timestamp;
};

/** @internal */
>>>>>>> origin/master
>>>>>>> da2dcd06e1a2d3788c7aa5c2e1802a945b20cf8a
export class ChangeStreamCursor<
  TSchema extends Document = Document,
  TChange extends Document = ChangeStreamDocument<TSchema>
> extends AbstractCursor<TChange, ChangeStreamEvents> {
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> da2dcd06e1a2d3788c7aa5c2e1802a945b20cf8a
  private _resumeToken: ResumeToken;
  private startAtOperationTime: OperationTime | null;
  private hasReceived?: boolean;
  private readonly changeStreamCursorOptions: ChangeStreamCursorOptions;
  private postBatchResumeToken?: ResumeToken;
  private readonly pipeline: Document[];
<<<<<<< HEAD
=======
=======
  _resumeToken: ResumeToken;
  startAtOperationTime?: OperationTime;
  hasReceived?: boolean;
  resumeAfter: ResumeToken;
  startAfter: ResumeToken;
  options: ChangeStreamCursorOptions;

  postBatchResumeToken?: ResumeToken;
  pipeline: Document[];
>>>>>>> origin/master
>>>>>>> da2dcd06e1a2d3788c7aa5c2e1802a945b20cf8a

  /**
   * @internal
   *
   * used to determine change stream resumability
   */
  maxWireVersion: number | undefined;

  constructor(
    client: MongoClient,
    namespace: MongoDBNamespace,
    pipeline: Document[] = [],
    options: ChangeStreamCursorOptions = {}
  ) {
    super(client, namespace, options);

    this.pipeline = pipeline;
<<<<<<< HEAD
    this.changeStreamCursorOptions = options;
    this._resumeToken = null;
    this.startAtOperationTime = options.startAtOperationTime ?? null;
=======
<<<<<<< HEAD
    this.changeStreamCursorOptions = options;
    this._resumeToken = null;
    this.startAtOperationTime = options.startAtOperationTime ?? null;
=======
    this.options = options;
    this._resumeToken = null;
    this.startAtOperationTime = options.startAtOperationTime;
>>>>>>> origin/master
>>>>>>> da2dcd06e1a2d3788c7aa5c2e1802a945b20cf8a

    if (options.startAfter) {
      this.resumeToken = options.startAfter;
    } else if (options.resumeAfter) {
      this.resumeToken = options.resumeAfter;
    }
  }

  set resumeToken(token: ResumeToken) {
    this._resumeToken = token;
    this.emit(ChangeStream.RESUME_TOKEN_CHANGED, token);
  }

  get resumeToken(): ResumeToken {
    return this._resumeToken;
  }

  get resumeOptions(): ChangeStreamCursorOptions {
    const options: ChangeStreamCursorOptions = {
<<<<<<< HEAD
      ...this.changeStreamCursorOptions
=======
<<<<<<< HEAD
      ...this.changeStreamCursorOptions
=======
      ...this.options
>>>>>>> origin/master
>>>>>>> da2dcd06e1a2d3788c7aa5c2e1802a945b20cf8a
    };

    for (const key of ['resumeAfter', 'startAfter', 'startAtOperationTime'] as const) {
      delete options[key];
    }

    if (this.resumeToken != null) {
<<<<<<< HEAD
      if (this.changeStreamCursorOptions.startAfter && !this.hasReceived) {
=======
<<<<<<< HEAD
      if (this.changeStreamCursorOptions.startAfter && !this.hasReceived) {
=======
      if (this.options.startAfter && !this.hasReceived) {
>>>>>>> origin/master
>>>>>>> da2dcd06e1a2d3788c7aa5c2e1802a945b20cf8a
        options.startAfter = this.resumeToken;
      } else {
        options.resumeAfter = this.resumeToken;
      }
    } else if (this.startAtOperationTime != null && maxWireVersion(this.server) >= 7) {
      options.startAtOperationTime = this.startAtOperationTime;
    }

    return options;
  }

  cacheResumeToken(resumeToken: ResumeToken): void {
    if (this.bufferedCount() === 0 && this.postBatchResumeToken) {
      this.resumeToken = this.postBatchResumeToken;
    } else {
      this.resumeToken = resumeToken;
    }
    this.hasReceived = true;
  }

<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> da2dcd06e1a2d3788c7aa5c2e1802a945b20cf8a
  _processBatch(response: CursorResponse): void {
    const { postBatchResumeToken } = response;
    if (postBatchResumeToken) {
      this.postBatchResumeToken = postBatchResumeToken;
<<<<<<< HEAD

      if (response.batchSize === 0) {
        this.resumeToken = postBatchResumeToken;
=======

      if (response.batchSize === 0) {
        this.resumeToken = postBatchResumeToken;
=======
  _processBatch(response: ChangeStreamAggregateRawResult<TChange>): void {
    const cursor = response.cursor;
    if (cursor.postBatchResumeToken) {
      this.postBatchResumeToken = response.cursor.postBatchResumeToken;

      const batch =
        'firstBatch' in response.cursor ? response.cursor.firstBatch : response.cursor.nextBatch;
      if (batch.length === 0) {
        this.resumeToken = cursor.postBatchResumeToken;
>>>>>>> origin/master
>>>>>>> da2dcd06e1a2d3788c7aa5c2e1802a945b20cf8a
      }
    }
  }

  clone(): AbstractCursor<TChange> {
    return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, {
      ...this.cursorOptions
    });
  }

<<<<<<< HEAD
  async _initialize(session: ClientSession): Promise<InitialCursorResponse> {
=======
<<<<<<< HEAD
  async _initialize(session: ClientSession): Promise<InitialCursorResponse> {
    const aggregateOperation = new AggregateOperation(this.namespace, this.pipeline, {
      ...this.cursorOptions,
      ...this.changeStreamCursorOptions,
      session
    });

    const response = await executeOperation(session.client, aggregateOperation);
=======
  async _initialize(session: ClientSession): Promise<ExecutionResult> {
>>>>>>> da2dcd06e1a2d3788c7aa5c2e1802a945b20cf8a
    const aggregateOperation = new AggregateOperation(this.namespace, this.pipeline, {
      ...this.cursorOptions,
      ...this.changeStreamCursorOptions,
      session
    });

<<<<<<< HEAD
    const response = await executeOperation(session.client, aggregateOperation);
=======
    const response = await executeOperation<
      TODO_NODE_3286,
      ChangeStreamAggregateRawResult<TChange>
    >(session.client, aggregateOperation);
>>>>>>> origin/master
>>>>>>> da2dcd06e1a2d3788c7aa5c2e1802a945b20cf8a

    const server = aggregateOperation.server;
    this.maxWireVersion = maxWireVersion(server);

    if (
      this.startAtOperationTime == null &&
<<<<<<< HEAD
      this.changeStreamCursorOptions.resumeAfter == null &&
      this.changeStreamCursorOptions.startAfter == null &&
=======
<<<<<<< HEAD
      this.changeStreamCursorOptions.resumeAfter == null &&
      this.changeStreamCursorOptions.startAfter == null &&
=======
      this.resumeAfter == null &&
      this.startAfter == null &&
>>>>>>> origin/master
>>>>>>> da2dcd06e1a2d3788c7aa5c2e1802a945b20cf8a
      this.maxWireVersion >= 7
    ) {
      this.startAtOperationTime = response.operationTime;
    }

    this._processBatch(response);

    this.emit(INIT, response);
    this.emit(RESPONSE);

<<<<<<< HEAD
=======
<<<<<<< HEAD
    return { server, session, response };
  }

  override async getMore(batchSize: number): Promise<CursorResponse> {
    const response = await super.getMore(batchSize);

    this.maxWireVersion = maxWireVersion(this.server);
    this._processBatch(response);
=======
    // TODO: NODE-2882
>>>>>>> da2dcd06e1a2d3788c7aa5c2e1802a945b20cf8a
    return { server, session, response };
  }

  override async getMore(batchSize: number): Promise<CursorResponse> {
    const response = await super.getMore(batchSize);

    this.maxWireVersion = maxWireVersion(this.server);
<<<<<<< HEAD
    this._processBatch(response);
=======
    this._processBatch(response as ChangeStreamAggregateRawResult<TChange>);
>>>>>>> origin/master
>>>>>>> da2dcd06e1a2d3788c7aa5c2e1802a945b20cf8a

    this.emit(ChangeStream.MORE, response);
    this.emit(ChangeStream.RESPONSE);
    return response;
  }
}
